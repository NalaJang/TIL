## MVC 패턴이란?

<div align = "center"><img src = "https://github.com/NalaJang/TIL/assets/73895803/91fc3c9a-8968-43c2-8f03-05cab253b395"/></div>

<br>

- 모델(Model), 뷰(View), 컨트롤러(Controller)로 이루어진 패턴

### Model
- 뷰에서 데이터를 생성하거나 수정하면 컨트롤러를 통해 모델을 생성하거나 갱신한다.

### View
- 모델이 가지고 있는 정보를 따로 저장하지 않아야한다.
- 단순히 화면에 표시하는 정보만 가지고 있어야 한다.
- 변경이 일어나면 컨트롤러에 전달한다.

### Controller
- 다리 역할을 하며 이벤트 등 메인 로직을 담당한다.
- 뷰와 모델의 생명주기를 관리한다.
- 뷰나 모델의 변경 통지를 받으면 이를 각각의 구성 요소에 해당 내용에 대해 알린다.

### 장점
- 직관적이고 단순한 구조
- 단순한 구조로 빠른 개발 진행

### 단점
- 컨트롤러는 특정 뷰와 모델에 의존적이며, 뷰도 특정 모델에 의존적이라서 결합도가 높다.
  - 컨트롤러의 책임이 커진다.
- 유닛 테스트가 거의 불가능하다.

<br></br>

## MVP 패턴이란?

<div align = "center"><img src = "https://github.com/NalaJang/TIL/assets/73895803/caaa77a3-16dc-4585-afae-6a5aab2defe5"/></div>

<br>

- MVC 패턴의 컨트롤러는 모델을 가져와서 데이터를 수정/변경/추가하는 비즈니스 로직도 존재하게 되어 UI 로직과 비즈니스 로직이 공존한다.
- MVP 패턴은 이 로직을 분리하는데 집중하여 생겨난 패턴이다.
- MVC에서 C에 해당하는 컨트롤러가 프레젠터(presenter)로 교체된 패턴
- 모델은 프레젠터를 모른다.

### Presenter
- 뷰와 모델을 연결해주는 역할로 UI 로직과 비즈니스 로직을 분리한다.
- 뷰와 프레젠터는 인터페이스를 통해 상호작용하므로 결합도가 낮다.
- 이 둘을 연결해주는 역할이기에 Presenter와 View는 1:1 관계이다.

### 장점
- MVC에서는 뷰에서 모델을 직접 생성하여 변경하기 때문에 의존적이었지만 MVP에서는 Presenter로 연결 부분을 두어 결합도를 약하게 만들었다.
- 유닛 테스트가 수월해졌다.

### 단점
- 뷰에서 프레젠터를 직접 생성하기 때문에 의존성이 높고 1:1 관계를 유지해야 해서 뷰가 많아질수록 프레젠터도 많아진다.

<br></br>

## MVVM 패턴이란?

<div align = "center"><img src = "https://github.com/NalaJang/TIL/assets/73895803/bdf2f8e9-ca5d-443d-abc8-231c55c40d4e"/></div>

<br>

[🔗 MVVM 패턴](https://velog.io/@k7120792/Model-View-ViewModel-Pattern)

- MVP에서는 뷰와 프레젠터가 1:1로 매칭되어야 하기 때문에 강하게 결합되어 있다는 문제가 있었다.
- 뷰는 뷰 모델을 알지만, 뷰 모델은 View를 알지 못한다.
- 뷰 모델은 모델은 알지만, 모델은 뷰 모델을 알지 못한다.
- 이런 구조를 통해서 뷰 모델과 모델이 뷰로부터 독립적인 형태를 만들어서, `UI로부터 비즈니스 로직과 프레젠테이션 로직 분리`를 하였다.
- 뷰 모델은 뷰를 더 추상화한 계층이며, 커맨드(command)와 데이터 바인딩(data binding)을 가진다.
- 뷰와 뷰 모델 사이의 양방향 데이터 바인딩을 지원하며 별도의 코드 수정 없이 UI를 재사용할 수 있고 단위 테스팅하기 쉽다.

<br>

### View Model
- View와 Model 사이의 중재자 역할
- View에서 발생하는 이벤트를 감지하고, 해당 이벤트에 맞는 비즈니스 로직을 수행한다.
- 데이터 바인딩을 사용하여 뷰 모델이 뷰에 대한 의존성을 갖지 않도록 연결한다. 따라서 뷰 모델은 특정 뷰에 의존적이지 않다.
- 뷰 모델과 Model은 1:N 관계이다.
- Model과 상호작용하여 데이터를 가져오거나 업데이트하고, View에 데이터를 업데이트하는 역할을 한다.
- 뷰 모델은 모델의 데이터를 가공해서 뷰에게 제공한다.
- 만약 뷰에서 서로 다은 두 모델의 데이터가 필요하다면 뷰에서 모델의 값을 조작해서 사용하는 것이 아니라,
- `뷰 모델에서 두 모델의 데이터를 가공하고 뷰에서는 오직 UI만 다루도록 해야 한다.`

<br>

### Command
- View의 이벤트와 뷰 모델의 비즈니스 로직 연결
- View와 뷰 모델의 의존성을 줄여준다.
- Command 객체는 View에서 데이터 바인딩을 통해 연결된다.
- 사용자가 버튼 클릭과 같은 UI 이벤트를 트리거(동작)할 때 뷰 모델의 명령 객체와 연결한다.
- 뷰 모델에서 정의한 비즈니스 로직을 View에서 호출할 수 있다. 사용자 입력을 처리하는 데 유용하다.

<br>

### Data Binding
- View와 뷰 모델 사이에 데이터를 동기화를 자동화하는 기술
- 이를 통해, View와 뷰 모델 간의 수동적인 데이터 전달을 줄인다.
#### 속성 바인딩
- View의 속성과 뷰 모델의 속성과 연결한다.
- 뷰 모델의 값이 변경될 때 View의 값도 자동으로 업데이트된다.
#### 이벤트 바인딩
- View의 이벤트를 뷰 모델의 명령이나 메서드에 연결한다.
- 사용자가 버튼을 클릭할 때 해당 메서드가 호출된다.

<br>

### 장점
- 한 쪽 방향으로만 의존 관계가 있어서 각 모듈별로 분리하여 개발할 수 있다.
- => 뷰 로직과 비즈니스 로직을 분리하여 생산성을 높힐 수 있다.(UI가 나오지 않아도 개발이 가능하다.)
- 의존성이 낮기 때문에 테스트가 수월하다.

### 단점
- 설계하기가 복잡하다. (Rx,데이터 바인딩에 대한 지식 필요)
- 뷰 모델이 비대해질 수 있다.
- 데이터 바인딩으로 인한 메모리 소모가 심해질 수 있다.

<br></br>

## Flutter의 Data Binding

- 전통적인 의미의 데이터 바인딩 매커니즘을 제공하지는 않지만, 상태 관리를 통해 UI와 데이터의 동기화를 구현할 수 있는, 데이터 바인딩과 유사한 기능을 제공하는 다른 방식이 있다.

#### StatefulWidget과 setState()
#### Provider 패키지
#### Riverpod
#### GetX
#### Bloc/Cubit
