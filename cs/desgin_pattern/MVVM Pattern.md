## MVVM 패턴이란?

<div align="center"><img src = "https://github.com/NalaJang/TIL/assets/73895803/bdf2f8e9-ca5d-443d-abc8-231c55c40d4e" /></div>

<br>

[🔗 MVVM 패턴](https://velog.io/@k7120792/Model-View-ViewModel-Pattern)

- MVC의 C에 해당하는 컨트롤러가 뷰 모델(view model)로 바뀐 패턴
- View는 뷰 모델을 알지만, 뷰 모델은 View를 알지 못한다.
- 뷰 모델은 Model은 알지만, Model은 뷰 모델을 알지 못한다.
- 이런 구조를 통해서 뷰 모델과 Model이 View로부터 독립적인 형태를 만들어서, `UI로부터 비즈니스 로직과 프레젠테이션 로직 분리`를 하였다.
- 뷰 모델은 뷰를 더 추상화한 계층이며, 커맨드(command)와 데이터 바인딩(data binding)을 가진다.
- View와 뷰 모델 사이의 양방향 데이터 바인딩을 지원하며 별도의 코드 수정 없이 UI를 재사용할 수 있고 단위 테스팅하기 쉽다.

<br>

### View Model
- View와 Model 사이의 중재자 역할
- View에서 발생하는 이벤트를 감지하고, 해당 이벤트에 맞는 비즈니스 로직을 수행한다.
- 뷰 모델과 Model은 1:n 관계이다.
- Model과 상호작용하여 데이터를 가져오거나 업데이트하고, View에 데이터를 업데이트하는 역할을 한다.
- 뷰 모델은 모델의 데이터를 가공해서 뷰에게 제공한다.
- 만약 뷰에서 서로 다은 두 모델의 데이터가 필요하다면 뷰에서 모델의 값을 조작해서 사용하는 것이 아니라, `뷰 모델에서 두 모델의 데이터를 가공하고 뷰에서는 오직 UI만 다루도록 해야 한다.`

<br>

### Command
- View의 이벤트와 뷰 모델의 비즈니스 로직 연결
- View와 뷰 모델의 의존성을 줄여준다.
- Command 객체는 View에서 데이터 바인딩을 통해 연결된다.
- 사용자가 버튼 클릭과 같은 UI 이벤트를 트리거(동작)할 때 뷰 모델의 명령 객체와 연결한다.
- 뷰 모델에서 정의한 비즈니스 로직을 View에서 호출할 수 있다. 사용자 입력을 처리하는 데 유용하다.

<br>

### Data Binding
- View와 뷰 모델 사이에 데이터를 동기화를 자동화하는 기술
- 이를 통해, View와 뷰 모델 간의 수동적인 데이터 전달을 줄인다.
#### 속성 바인딩
- View의 속성과 뷰 모델의 속성과 연결한다.
- 뷰 모델의 값이 변경될 때 View의 값도 자동으로 업데이트된다.
#### 이벤트 바인딩
- View의 이벤트를 뷰 모델의 명령이나 메서드에 연결한다.
- 사용자가 버튼을 클릭할 때 해당 메서드가 호출된다.

<br>

### 장점
- 뷰 로직과 비즈니스 로직을 분리하여 생산성을 높힐 수 있다.(UI가 나오지 않아도 개발이 가능하다.)
- 의존성이 낮기 때문에 테스트가 수월하다.

### 단점
- 설계하기가 복잡하다. (Rx,데이터 바인딩에 대한 지식 필요)
- 뷰 모델이 비대해질 수 있다.
- 데이터 바인딩으로 인한 메모리 소모가 심해질 수 있다.

<br></br>

## Flutter의 Data Binding

- 전통적인 의미의 데이터 바인딩 매커니즘을 제공하지는 않지만, 상태 관리를 통해 UI와 데이터의 동기화를 구현할 수 있는, 데이터 바인딩과 유사한 기능을 제공하는 다른 방식이 있다.

#### StatefulWidget과 setState()
#### Provider 패키지
#### Riverpod
#### GetX
#### Bloc/Cubit
