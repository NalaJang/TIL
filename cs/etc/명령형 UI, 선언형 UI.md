
<div align = "center"><img width = "650" src = "https://github.com/NalaJang/TIL/assets/73895803/c4639b44-1520-4cb4-adfa-194da8de46f2"/></div>

## 명령형 UI
* UI를 어떻게 구성할 지, 상태 변화에 따라 어떻게 업데이트할 지를 `함수의 호출`을 통한 명령어로 작성한다.

<br>

### 장점
* 세밀한 제어 : UI의 모든 세부 사항을 명시적으로 제어할 수 있다.
* 익숨함 : 전통적인 프로그래밍 방식으로 기존 개발자에게 친숙하다.

<br>

### 단점
* 복잡성 증가 : 상태와 UI 간의 매핑을 명시적으로 작성해야 하므로 복잡성이 증가할 수 있다.
* 유지보수 어려움
* 버그 발생 가능성 : 상태와 UI의 불일치로 인해 버그가 발생할 가능성이 높다.

<br></br>

## 선언형 UI
* UI가 어떤 모습이어야 하는지를 선언한다.
* UI는 데이터 상태에 기반하여 자동으로 업데이트되며, 상태가 변경되면 UI도 자동으로 갱신된다.

<br>

### 장점
* 코드 간결함 : 상태가 변경되면 UI가 자동으로 갱신되므로 코드가 간결해진다.
* 유지보수 용이
* 버그 감소

<br>

### 단점
* 성능 문제 : 자동 갱신 방식으로 인해 불필요한 업데이트가 발생할 수 있다.
* 제한된 제어 : UI 업데이트를 세밀하게 제어하기 어렵다.

<br>

## 비교

<img width="647" alt="image" src="https://github.com/NalaJang/TIL/assets/73895803/208d27e3-6d81-4a0e-ab40-20afacfb9420">

<br></br>

## 선언형 UI가 나오게 된 이유?

[🔗 사람들은 왜 선언형 UI에 열광할까?](https://medium.com/@kimdohun0104/%EC%82%AC%EB%9E%8C%EB%93%A4%EC%9D%80-%EC%99%9C-%EC%84%A0%EC%96%B8%ED%98%95-ui%EC%97%90-%EC%97%B4%EA%B4%91%ED%95%A0%EA%B9%8C-1440d03f4e49)
* Android를 예시로 하자면, 커스텀 뷰를 작성하기 위해 다양한 파일을 작성해야 한다. 간단한 로그인 버튼을 재활용하기 위해서 많은 비용이 소모된다. 이는 생산성을 크게 낮춘다.
* 즉, UI를 어떻게 구현할 것인지 개발자가 상세하게 기술해야 하므로 재사용성과 확장성이 떨어진다.

* 선언형 UI는 상태와 함께 `무엇을` 렌더링할 지 정의하면 자세한 부분은 프레임워크에서 처리해준다.
* 이는 상태와 UI의 동기화를 자연스럽게 처리하고, 코드의 유지보수성과 가독성을 높이기 위한 효율적인 방법이다.
* 다양한 프레임워크가 선언형 UI의 이점을 활용하여, 개발자들이 더 나은 사용자 경험을 제공할 수 있도록 지원하고 있다.

<br>

#### 선언형 UI에서의 한 가지 공식
<div align = "center"><img width = "650" src = "https://github.com/NalaJang/TIL/assets/73895803/30ce2a09-a3fb-44e7-b644-136e7e12443e" /></div>

<br>

* '위젯 또는 함수'의 인자로 상태를 넘겨주면, 그에 맞는 View를 생성한다.
* 함수형 프로그래밍 개념의 순수 함수처럼 같은 상태에 대해서는 항상 똑같은 View를 리턴한다.

<br></br>

## Flutter의 선언형 UI

## Flutter의 3가지 트리

[🔗 Flutter의 위젯 렌더링](https://medium.com/@kimdohun0104/%ED%94%8C%EB%9F%AC%ED%84%B0%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%9C%84%EC%A0%AF%EC%9D%84-%EB%A0%8C%EB%8D%94%EB%A7%81%ED%95%A0%EA%B9%8C-%EB%B0%9C%ED%91%9C-%EC%98%81%EC%83%81-70a726f4e53e)

<img width="743" alt="image" src="https://github.com/NalaJang/TIL/assets/73895803/389405e2-99b6-4d78-932c-ce5c2f3ddb7b">

* 만약 하나의 위젯 트리만 존재했다면 수시로 렌더링이 자주 발생하는 앱 같은 경우 모든 위젯이 다시 렌더링되어야 하는 문제가 발생할 것이다.
* flutter는 3가지로 나누어 적절한 시점에 따로 렌더링 되어 성능적으로 이득을 가져간다.

<br>

### Widget Tree
* 속성에 대한 정보
* 각 객체는 immnutable(불변) 구성으로 되어있어 생성 및 파기 비용이 매우 작게 설계되어있다.
* fontSize, text, style 등

<br>

### Element Tree
* 부모, 자식 관계에 대한 정보
* mutable로 구성되어 있다.
* 위젯의 트리의 상태를 관리하고, 렌더 트리의 생명주기를 관리

<br>

### Render Object Tree
* 위젯의 크기, 레이아웃에 대한 정보
* 화면에 어떻게 그릴지에 대한 로직

<img width="634" alt="image" src="https://github.com/NalaJang/TIL/assets/73895803/ab04d206-16f6-4c3f-8f22-937cebb779f5">

플러터는 build 단계에서 위젯 트리(widget tree)와 엘리먼트 트리(element tree)를 만들고, layout 단계에서 렌더 트리(render tree)를 만든 다음 paint 단계에서 가장 마지막에 만든 렌더 트리를 써먹는다. 앞서 만든 위젯 트리, 엘리먼트 트리는 모두 렌더 트리를 만들기 위해서 생성하는 트리다. 그리고 엘리먼트 트리 역시 위젯 트리를 바탕으로 만들어진다.  
렌더 트리는 바뀐 부분만 다시 렌더링 해서 보여준다. 1초 60프레임을 만들기 위함

#### 즉, 상태와 렌더링 목적의 기능을 3가지 트리로 분리하고, 변화가 발생했을 때 비용이 적고, 변화가 발생한 위젯만 재구성하므로 비용을 최소화하고 성능을 최적화하는 목적을 가지고 있다.
